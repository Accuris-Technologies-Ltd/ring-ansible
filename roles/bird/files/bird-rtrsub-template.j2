define ROAS = [
        {% for prefix in aggregated_pfx_list -%}
{{ prefix }}+
{%- if not loop.last -%},{%- endif -%}
{%- if loop.index % 4 == 0 -%}
{{ "\n        " }}
{%- else -%}
{{ " " }}
{%- endif -%}
{%- endfor %}
    ];

function is_roa_covered_prefix()
prefix set roas;
{
    roas = ROAS;
    if net ~ roas then {
        return true;
    }
    else return false;
}

function complies_with_roa()
{
    case net {
{%- for prefix in pfx_dict %}
{%- if pfx_dict[prefix]["prefixlen"] == pfx_dict[prefix]["maxlength"] %}
    {{ prefix }}:
{%- else %}
    {{ prefix }}{{ "{" }}{{ pfx_dict[prefix]["prefixlen"] }},{{ pfx_dict[prefix]["maxlength"] }}{{ "}" }}:
{%- endif %}
{%- for origin in pfx_dict[prefix]["origins"]|sort(reverse=True) %}
            if bgp_path.last = {{ origin }} then return true;
{%- endfor %}
{%- endfor %}
    else:
        return false;
}

function flag_rpki_state()
{
    if is_roa_covered_prefix() then {
        if complies_with_roa() then {
            /* add marker to routes for which a valid matching ROA exists */
            bgp_ext_community.add((unknown 0x4300, 0, 0));
        }
        else {
            bgp_ext_community.add((unknown 0x4300, 0, 2));
        }
    } else {
        bgp_ext_community.add((unknown 0x4300, 0, 1));
    }
}
